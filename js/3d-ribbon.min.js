import*as THREE from"three";import{EffectComposer}from"three/addons/postprocessing/EffectComposer.js";import{RenderPass}from"three/addons/postprocessing/RenderPass.js";import{UnrealBloomPass}from"three/addons/postprocessing/UnrealBloomPass.js";class SimplexNoise{constructor(t=Math.random()){this.p=new Uint8Array(256);for(let t=0;t<256;t++)this.p[t]=t;const e=this._createSeededRandom(t);for(let t=255;t>0;t--){const s=Math.floor(e()*(t+1));[this.p[t],this.p[s]]=[this.p[s],this.p[t]]}this.perm=new Uint8Array(512),this.permMod12=new Uint8Array(512);for(let t=0;t<512;t++)this.perm[t]=this.p[255&t],this.permMod12[t]=this.perm[t]%12}_createSeededRandom(t){return function(){const e=1e4*Math.sin(t++);return e-Math.floor(e)}}noise3D(t,e,s){const i=[[1,1,0],[-1,1,0],[1,-1,0],[-1,-1,0],[1,0,1],[-1,0,1],[1,0,-1],[-1,0,-1],[0,1,1],[0,-1,1],[0,1,-1],[0,-1,-1]],o=1/6,r=(t+e+s)*(1/3),n=Math.floor(t+r),h=Math.floor(e+r),a=Math.floor(s+r),l=(n+h+a)*o,c=t-(n-l),u=e-(h-l),d=s-(a-l);let p,m,g,f,C,M;c>=u?u>=d?(p=1,m=0,g=0,f=1,C=1,M=0):c>=d?(p=1,m=0,g=0,f=1,C=0,M=1):(p=0,m=0,g=1,f=1,C=0,M=1):u<d?(p=0,m=0,g=1,f=0,C=1,M=1):c<d?(p=0,m=1,g=0,f=0,C=1,M=1):(p=0,m=1,g=0,f=1,C=1,M=0);const w=c-p+o,b=u-m+o,I=d-g+o,R=c-f+2*o,E=u-C+2*o,v=d-M+2*o,T=c-1+.5,y=u-1+.5,O=d-1+.5,P=255&n,F=255&h,x=255&a,G=this.permMod12[P+this.perm[F+this.perm[x]]],N=this.permMod12[P+p+this.perm[F+m+this.perm[x+g]]],H=this.permMod12[P+f+this.perm[F+C+this.perm[x+M]]],k=this.permMod12[P+1+this.perm[F+1+this.perm[x+1]]];let D=.6-c*c-u*u-d*d,X=0;D>=0&&(D*=D,X=D*D*(i[G][0]*c+i[G][1]*u+i[G][2]*d));let Y=.6-w*w-b*b-I*I,L=0;Y>=0&&(Y*=Y,L=Y*Y*(i[N][0]*w+i[N][1]*b+i[N][2]*I));let z=.6-R*R-E*E-v*v,A=0;z>=0&&(z*=z,A=z*z*(i[H][0]*R+i[H][1]*E+i[H][2]*v));let S=.6-T*T-y*y-O*O,V=0;return S>=0&&(S*=S,V=S*S*(i[k][0]*T+i[k][1]*y+i[k][2]*O)),32*(X+L+A+V)}}const CONFIG={lineCount:42,ribbonWidthRatio:.5,pointsPerLine:350,drawDuration:2500,morphDuration:3e3,staggerDelay:45,holdDuration:3e3,curveScaleMultiplier:.69,depthMultiplier:.15,numControlPoints:100,ribbonCount:1,rotationSpeed:75e-5,baseTiltX:.25,baseTiltZ:.12,numCurveVariations:13,lineColor:1118481,backgroundColor:16316404,lightLineColor:3421236,lightBackgroundColor:16118767,lightFillColor:16118767,darkLineColor:13684944,darkBackgroundColor:1184274,darkFillColor:1973790,rippleColors:[[180,140,40],[140,100,110],[90,100,120],[160,85,45],[45,120,80],[150,45,55],[55,75,145],[95,55,130],[145,95,50],[110,110,125]],rippleTravelTime:2500,rippleFadeTime:3e3,rippleWidth:.25,rippleIntensity:1.4,dragInfluence:.5,influenceLerp:.04,mouseLightRadius:80,mouseLightIntensity:.4,colorCycleTime:2500,hoverPreviewIntensity:.35};CONFIG.fillColor=CONFIG.lightFillColor;const isDarkMode=document.documentElement.classList.contains("dark");isDarkMode&&(CONFIG.lineColor=CONFIG.darkLineColor,CONFIG.backgroundColor=CONFIG.darkBackgroundColor,CONFIG.fillColor=CONFIG.darkFillColor),window.addEventListener("themechange",t=>{const e=t.detail?.isDark,s=e?CONFIG.darkLineColor:CONFIG.lightLineColor,i=e?CONFIG.darkBackgroundColor:CONFIG.lightBackgroundColor,o=e?CONFIG.darkFillColor:CONFIG.lightFillColor;if(window.ribbonManager){const t=500,e=performance.now(),r=window.ribbonManager.scene.background.clone(),n=new THREE.Color(i),h=new THREE.Color(CONFIG.lineColor),a=new THREE.Color(s),l=new THREE.Color(CONFIG.fillColor),c=new THREE.Color(o);requestAnimationFrame(function u(d){const p=d-e,m=Math.min(p/t,1),g=m<.5?2*m*m:1-Math.pow(-2*m+2,2)/2;window.ribbonManager.scene.background.lerpColors(r,n,g);const f=(new THREE.Color).lerpColors(h,a,g),C=(new THREE.Color).lerpColors(l,c,g);for(const t of window.ribbonManager.ribbons){for(const e of t.lines)e.updateBaseColor(f.getHex());for(const e of t.fillMeshes)e.mesh.material.color.copy(C)}m<1?requestAnimationFrame(u):(CONFIG.lineColor=s,CONFIG.backgroundColor=i,CONFIG.fillColor=o)})}else CONFIG.lineColor=s,CONFIG.backgroundColor=i,CONFIG.fillColor=o});const CURVE_OPTIMAL_ROTATIONS=[{x:.15,y:.3,z:.1},{x:.25,y:.4,z:.1},{x:.3,y:.2,z:.05},{x:.2,y:.5,z:.12},{x:.22,y:.35,z:.08},{x:.28,y:.25,z:.1},{x:.2,y:.45,z:.12},{x:.22,y:.38,z:.08},{x:.2,y:.35,z:.1},{x:.25,y:.35,z:.1},{x:.24,y:.4,z:.1},{x:.22,y:.38,z:.08},{x:.26,y:.32,z:.1}];function computeParallelTransport(t,e){const s={tangents:[],normals:[],binormals:[]};for(let i=0;i<=e;i++)s.tangents.push(t.getTangent(i/e).normalize());const i=s.tangents[0];let o=Math.abs(i.x)<.9?new THREE.Vector3(1,0,0):new THREE.Vector3(0,1,0);o.crossVectors(o,i).normalize();const r=[o.clone()];for(let t=1;t<=e;t++){const e=s.tangents[t-1],i=s.tangents[t],n=(new THREE.Vector3).crossVectors(e,i);if(n.length()>1e-4){n.normalize();const s=Math.acos(Math.min(1,Math.max(-1,e.dot(i))));o=r[t-1].clone().applyAxisAngle(n,s)}else o=r[t-1].clone();r.push(o)}const n=r[0],h=r[e],a=s.tangents[e],l=n.clone().projectOnPlane(a).normalize(),c=h.clone().projectOnPlane(a).normalize();let u=Math.acos(Math.min(1,Math.max(-1,l.dot(c))));(new THREE.Vector3).crossVectors(c,l).dot(a)<0&&(u=-u);for(let t=0;t<=e;t++){const i=u*t/e,o=r[t].clone().applyAxisAngle(s.tangents[t],i);s.normals.push(o),s.binormals.push((new THREE.Vector3).crossVectors(s.tangents[t],o))}return s}function createLissajousKnot(t,e,s,i,o,r,n,h){const a=[];for(let l=0;l<h;l++){const c=l/h*Math.PI*2;a.push(new THREE.Vector3(Math.cos(t*c+i)*n.x,Math.cos(e*c+o)*n.y,Math.cos(s*c+r)*n.z))}return new THREE.CatmullRomCurve3(a,!0,"centripetal",.5)}function createTorusKnot(t,e,s,i,o,r){const n=[];for(let h=0;h<r;h++){const a=h/r*Math.PI*2;n.push(new THREE.Vector3(Math.cos(t*a)*(s+i*Math.cos(e*a))*o,Math.sin(t*a)*(s+i*Math.cos(e*a))*o,i*Math.sin(e*a)*o))}return new THREE.CatmullRomCurve3(n,!0,"centripetal",.5)}function createTrefoil(t,e){const s=[];for(let i=0;i<e;i++){const o=i/e*Math.PI*2;s.push(new THREE.Vector3((Math.sin(o)+2*Math.sin(2*o))*t*.35,(Math.cos(o)-2*Math.cos(2*o))*t*.35,-Math.sin(3*o)*t*.25))}return new THREE.CatmullRomCurve3(s,!0,"centripetal",.5)}function createFigure8Knot(t,e){const s=[];for(let i=0;i<e;i++){const o=i/e*Math.PI*2;s.push(new THREE.Vector3((2+Math.cos(2*o))*Math.cos(3*o)*t*.22,(2+Math.cos(2*o))*Math.sin(3*o)*t*.22,Math.sin(4*o)*t*.18))}return new THREE.CatmullRomCurve3(s,!0,"centripetal",.5)}function createCinquefoil(t,e){const s=[];for(let i=0;i<e;i++){const o=i/e*Math.PI*2;s.push(new THREE.Vector3(Math.cos(2*o)*(3+Math.cos(5*o))*t*.12,Math.sin(2*o)*(3+Math.cos(5*o))*t*.12,Math.sin(5*o)*t*.15))}return new THREE.CatmullRomCurve3(s,!0,"centripetal",.5)}class Line3D{constructor(t,e,s,i,o){this.scene=s,this.noise=i,this.index=t;const r=(e-1)/2;this.baseOffset=(t-r)*o,this.drawProgress=0,this.morphProgress=0,this.oldPositions=null,this.newPositions=null,this.isMorphing=!1,this.mesh=null}startMorph(t,e){if(!this.mesh)return;const s=this.mesh.geometry.attributes.position;this.oldPositions=new Float32Array(s.array),this.newPositions=new Float32Array(this.generatePositions(t,e)),this.isMorphing=!0,this.morphProgress=0}interpolateMorph(t){if(!this.isMorphing||!this.oldPositions||!this.newPositions)return;if(!this.mesh)return;const e=this.mesh.geometry.attributes.position,s=e.count,i=.15,o=1.3*t-.15;for(let t=0;t<s;t++){const r=t/(s-1);let n;if(r<=o-i)n=1;else if(r>=o+i)n=0;else{const t=(o+i-r)/.3;n=t*t*(3-2*t)}const h=3*t;e.array[h]=this.oldPositions[h]+(this.newPositions[h]-this.oldPositions[h])*n,e.array[h+1]=this.oldPositions[h+1]+(this.newPositions[h+1]-this.oldPositions[h+1])*n,e.array[h+2]=this.oldPositions[h+2]+(this.newPositions[h+2]-this.oldPositions[h+2])*n}e.needsUpdate=!0}finishMorph(){this.isMorphing=!1,this.oldPositions=null,this.newPositions=null}updateBaseColor(t){if(this.baseColor=new THREE.Color(t),this.mesh){const t=this.mesh.geometry.attributes.color;if(t){for(let e=0;e<t.count;e++)t.array[3*e]=this.baseColor.r,t.array[3*e+1]=this.baseColor.g,t.array[3*e+2]=this.baseColor.b;t.needsUpdate=!0}}}generatePositions(t,e){const s=[],i=computeParallelTransport(t,CONFIG.pointsPerLine);for(let e=0;e<=CONFIG.pointsPerLine;e++){const o=e/CONFIG.pointsPerLine,r=t.getPoint(o),n=i.binormals[e],h=this.baseOffset;s.push(r.x+n.x*h,r.y+n.y*h,r.z+n.z*h)}return s}createMesh(t,e){this.mesh&&(this.mesh.geometry.dispose(),this.scene.remove(this.mesh));const s=this.generatePositions(t,e),i=new THREE.BufferGeometry;i.setAttribute("position",new THREE.Float32BufferAttribute(s,3));const o=s.length/3,r=new Float32Array(3*o),n=new THREE.Color(CONFIG.lineColor);for(let t=0;t<o;t++)r[3*t]=n.r,r[3*t+1]=n.g,r[3*t+2]=n.b;i.setAttribute("color",new THREE.Float32BufferAttribute(r,3));const h=new THREE.LineBasicMaterial({vertexColors:!0,depthWrite:!0,depthTest:!0});this.mesh=new THREE.Line(i,h),this.mesh.renderOrder=1,this.scene.add(this.mesh),this.baseColor=n.clone(),i.setDrawRange(0,0)}updatePositions(t,e){if(!this.mesh)return;const s=this.generatePositions(t,e),i=this.mesh.geometry.attributes.position;for(let t=0;t<s.length;t++)i.array[t]=s[t];i.needsUpdate=!0}applyRipple(t,e,s,i){if(!this.mesh||!this.baseColor)return;const o=this.mesh.geometry.attributes.color;if(!o)return;const r=o.count,n=CONFIG.rippleWidth;for(let h=0;h<r;h++){const a=h/(r-1);let l=Math.abs(a-t);l>.5&&(l=1-l);const c=.5*s;let u=0,d=0;if(s<1){if(l<=c){const t=c-l;if(t<n){u=Math.sin((1-t/n)*Math.PI*.5);const e=.03;t<e&&(d=Math.pow(1-t/e,2))}}if(l<.3*n){const t=1-l/(.3*n);u=Math.max(u,t)}}else if(l<=.5){u=(1-.5*l)*(1-Math.pow(i,.4))}u=Math.min(1,u*CONFIG.rippleIntensity);let p=this.baseColor.r+(e.r-this.baseColor.r)*u,m=this.baseColor.g+(e.g-this.baseColor.g)*u,g=this.baseColor.b+(e.b-this.baseColor.b)*u;if(d>0){const t=.5*d;p=Math.min(1,p+(1-p)*t),m=Math.min(1,m+(1-m)*t),g=Math.min(1,g+(1-g)*t)}o.array[3*h]=p,o.array[3*h+1]=m,o.array[3*h+2]=g}o.needsUpdate=!0}resetColors(){if(!this.mesh||!this.baseColor)return;const t=this.mesh.geometry.attributes.color;if(t){for(let e=0;e<t.count;e++)t.array[3*e]=this.baseColor.r,t.array[3*e+1]=this.baseColor.g,t.array[3*e+2]=this.baseColor.b;t.needsUpdate=!0}}dispose(){this.mesh&&(this.mesh.geometry.dispose(),this.mesh.material.dispose(),this.scene.remove(this.mesh))}}class Ribbon3D{constructor(t,e,s=null){this.scene=t,this.noise=e,this.manager=s,this.time=0,this.lines=[],this.fillMeshes=[],this.curves=[],this.currentCurveIndex=0,this.nextCurveIndex=1,this.generateCurveVariations(),this.phase="drawing",this.phaseStartTime=0,this.holdTimer=0,this.rotationTime=0,this.ribbonGroup=new THREE.Group,this.scene.add(this.ribbonGroup);const i=this.curveOrder[0];this.currentCurveIndex=i;const o=CURVE_OPTIMAL_ROTATIONS[i]||{x:.2,y:.3,z:.1};this.ribbonGroup.rotation.set(o.x,o.y,o.z),this.rotationTime=o.y/.06;for(let t=0;t<CONFIG.lineCount;t++){const e=new Line3D(t,CONFIG.lineCount,this.ribbonGroup,this.noise,this.lineSpacing);e.createMesh(this.curves[i],this.time),this.lines.push(e)}this.createFillMeshes()}generateCurveVariations(){const t=window.innerWidth,e=window.innerHeight,s=Math.min(t,e)*CONFIG.curveScaleMultiplier,i=s*CONFIG.depthMultiplier,o=CONFIG.numControlPoints,r=s*(Math.min(t,e)<600?.7:.5);this.lineSpacing=r/(CONFIG.lineCount-1);const n=[];for(let t=0;t<o;t++){const e=t/o*Math.PI*2;n.push(new THREE.Vector3(Math.sin(e)*s*.9,Math.sin(2*e)*s*.55,Math.sin(e+Math.PI/4)*i*1.5))}this.curves.push(new THREE.CatmullRomCurve3(n,!0,"centripetal",.5)),this.curves.push(createTrefoil(1.3*s,o)),this.curves.push(createTorusKnot(2,3,.6*s,.35*s,1,o)),this.curves.push(createLissajousKnot(2,3,5,0,Math.PI/4,0,{x:s,y:.75*s,z:i},o)),this.curves.push(createTorusKnot(2,5,.5*s,.28*s,1,o)),this.curves.push(createTorusKnot(3,2,.55*s,.32*s,1,o)),this.curves.push(createTorusKnot(3,4,.48*s,.26*s,1,o)),this.curves.push(createTorusKnot(2,7,.5*s,.28*s,1,o));const h=[],a=.65*s;for(let t=0;t<o;t++){const e=t/o*Math.PI*2;h.push(new THREE.Vector3(a*Math.pow(Math.cos(e),3),a*Math.pow(Math.sin(e),3),.6*i*Math.sin(2*e)))}this.curves.push(new THREE.CatmullRomCurve3(h,!0,"centripetal",.5)),this.curves.push(createTorusKnot(3,5,.52*s,.28*s,1,o)),this.curves.push(createTorusKnot(3,7,.48*s,.25*s,1,o));const l=[],c=.55*s;for(let t=0;t<o;t++){const e=t/o*Math.PI*2;l.push(new THREE.Vector3(c*(2*Math.cos(e)+Math.cos(2*e)),c*(2*Math.sin(e)-Math.sin(2*e)),.7*i*Math.sin(1.5*e)))}this.curves.push(new THREE.CatmullRomCurve3(l,!0,"centripetal",.5)),this.curves.push(createTorusKnot(4,3,.5*s,.28*s,1,o)),this.curveOrder=this.shuffleArray([...Array(this.curves.length).keys()]),this.curveOrderIndex=0}shuffleArray(t){const e=[...t];for(let t=e.length-1;t>0;t--){const s=Math.floor(Math.random()*(t+1));[e[t],e[s]]=[e[s],e[t]]}return e}createFillMeshes(){for(let t=0;t<this.lines.length-1;t++){const e=this.lines[t],s=this.lines[t+1],i=new THREE.BufferGeometry,o=[],r=[],n=e.mesh.geometry.attributes.position.array,h=s.mesh.geometry.attributes.position.array,a=CONFIG.pointsPerLine+1;for(let t=0;t<a;t++){const e=3*t;o.push(n[e],n[e+1],n[e+2]),o.push(h[e],h[e+1],h[e+2])}const l=2*(a-1);for(let t=0;t<a-1;t++){const e=2*t;r.push(e,e+1,e+2),r.push(e+1,e+3,e+2)}i.setAttribute("position",new THREE.Float32BufferAttribute(o,3)),i.setIndex(r);const c=new THREE.MeshBasicMaterial({color:new THREE.Color(CONFIG.fillColor),side:THREE.DoubleSide,depthWrite:!0,depthTest:!0,polygonOffset:!0,polygonOffsetFactor:2,polygonOffsetUnits:2}),u=new THREE.Mesh(i,c);u.renderOrder=-1,this.ribbonGroup.add(u),this.fillMeshes.push({mesh:u,line1Index:t,line2Index:t+1,totalTriangles:l}),i.setDrawRange(0,0)}}updateFillMeshPositions(t){const e=this.fillMeshes[t],s=this.lines[e.line1Index],i=this.lines[e.line2Index],o=s.mesh.geometry.attributes.position.array,r=i.mesh.geometry.attributes.position.array,n=e.mesh.geometry.attributes.position.array,h=CONFIG.pointsPerLine+1;for(let t=0;t<h;t++){const e=3*t,s=6*t;n[s]=o[e],n[s+1]=o[e+1],n[s+2]=o[e+2],n[s+3]=r[e],n[s+4]=r[e+1],n[s+5]=r[e+2]}e.mesh.geometry.attributes.position.needsUpdate=!0}updateFillMeshes(){const t=CONFIG.pointsPerLine+1-1;for(let e=0;e<this.fillMeshes.length;e++){const s=this.fillMeshes[e],i=this.lines[s.line1Index],o=this.lines[s.line2Index];let r,n;"drawing"===this.phase?(r=i.drawProgress,n=o.drawProgress):"morphing"===this.phase?(r=i.morphProgress<=.5?1-2*i.morphProgress:2*(i.morphProgress-.5),n=o.morphProgress<=.5?1-2*o.morphProgress:2*(o.morphProgress-.5)):(r=1,n=1);const h=Math.min(r,n),a=6*Math.floor(h*t);s.mesh.geometry.setDrawRange(0,a)}}updateRotation(t){void 0===this.spinRateX&&(this.spinRateX=14e-6,this.spinRateY=56e-6,this.currentRotationX=CONFIG.baseTiltX,this.currentRotationY=0,this.currentRotationZ=CONFIG.baseTiltZ,this.lastDragX=0,this.lastDragY=0);const e=this.manager?.dragOffsetX||0,s=this.manager?.dragOffsetY||0,i=e-this.lastDragX,o=s-this.lastDragY;this.lastDragX=e,this.lastDragY=s,this.spinRateY+=56e-5*o,this.spinRateX+=42e-5*i,this.spinRateY=Math.max(-28e-5,Math.min(28e-5,this.spinRateY)),this.spinRateX=Math.max(-21e-5,Math.min(21e-5,this.spinRateX)),this.currentRotationX+=this.spinRateX*t,this.currentRotationY+=this.spinRateY*t,this.rotationTime=(this.rotationTime||0)+t*CONFIG.rotationSpeed;const r=CONFIG.baseTiltZ+.06*Math.sin(.5*this.rotationTime);this.ribbonGroup.rotation.set(this.currentRotationX,this.currentRotationY,r)}update(t){this.time+=.001*t,this.updateRotation(t);const e=CONFIG.pointsPerLine+1,s=1e3*this.time-this.phaseStartTime;switch(this.phase){case"drawing":for(let t=0;t<this.lines.length;t++){const i=t*CONFIG.staggerDelay;if(s>=i){const o=s-i;this.lines[t].drawProgress=Math.min(1,o/CONFIG.drawDuration);const r=Math.floor(this.lines[t].drawProgress*e);this.lines[t].mesh.geometry.setDrawRange(0,r)}}this.lines[this.lines.length-1].drawProgress>=1&&(this.phase="holding",this.phaseStartTime=1e3*this.time,this.holdTimer=0);break;case"holding":if(this.holdTimer+=t,this.holdTimer>=CONFIG.holdDuration){this.phase="morphing",this.phaseStartTime=1e3*this.time,this.curveSwapped=!1,this.nextCurveIndex=this.curveOrder[this.curveOrderIndex],this.curveOrderIndex=(this.curveOrderIndex+1)%this.curveOrder.length,this.nextCurveIndex===this.currentCurveIndex&&this.curves.length>1&&(this.nextCurveIndex=this.curveOrder[this.curveOrderIndex],this.curveOrderIndex=(this.curveOrderIndex+1)%this.curveOrder.length),0===this.curveOrderIndex&&(this.curveOrder=this.shuffleArray(this.curveOrder));for(const t of this.lines)t.morphProgress=0}break;case"morphing":for(let t=0;t<this.lines.length;t++){const i=this.lines[t],o=t*CONFIG.staggerDelay;if(s>=o){const r=s-o,n=i.morphProgress;if(i.morphProgress=Math.min(1,r/CONFIG.morphDuration),n<.5&&i.morphProgress>=.5&&(i.updatePositions(this.curves[this.nextCurveIndex],this.time),t>0&&this.fillMeshes[t-1]&&this.updateFillMeshPositions(t-1),t<this.lines.length-1&&this.fillMeshes[t]&&this.updateFillMeshPositions(t)),i.morphProgress<=.5){const t=2*i.morphProgress,s=Math.floor((1-t)*e);i.mesh.geometry.setDrawRange(0,Math.max(1,s))}else{const t=2*(i.morphProgress-.5),s=Math.floor(t*e);i.mesh.geometry.setDrawRange(0,s)}}}this.updateFillMeshes();if(this.lines[this.lines.length-1].morphProgress>=1){this.phase="holding",this.phaseStartTime=1e3*this.time,this.holdTimer=0,this.currentCurveIndex=this.nextCurveIndex;for(const t of this.lines)t.finishMorph(),t.drawProgress=1,t.mesh.geometry.setDrawRange(0,e)}}this.updateFillMeshes()}dispose(){for(const t of this.lines)t.dispose();for(const t of this.fillMeshes)t.mesh.geometry.dispose(),t.mesh.material.dispose(),this.ribbonGroup.remove(t.mesh);this.fillMeshes=[],this.scene.remove(this.ribbonGroup)}}class RibbonManager{constructor(){this.width=window.innerWidth,this.height=window.innerHeight,this.scene=new THREE.Scene,this.scene.background=new THREE.Color(CONFIG.backgroundColor);Math.min(this.width,this.height);this.camera=new THREE.OrthographicCamera(-this.width/2,this.width/2,this.height/2,-this.height/2,.1,3e3),this.camera.position.z=1e3,this.isMobile=/Android|iPhone|iPad|iPod/i.test(navigator.userAgent),this.renderer=new THREE.WebGLRenderer({canvas:document.getElementById("ribbon-js"),antialias:!0,alpha:!1,powerPreference:"high-performance",stencil:!1,depth:!0,premultipliedAlpha:!1,preserveDrawingBuffer:!1,failIfMajorPerformanceCaveat:!1}),this.renderer.setSize(this.width,this.height);const t=this.isMobile?1.5:2;this.renderer.setPixelRatio(Math.min(window.devicePixelRatio,t)),this.composer=new EffectComposer(this.renderer),this.composer.addPass(new RenderPass(this.scene,this.camera)),this.mouseInfluenceX=0,this.mouseInfluenceY=0,this.dragOffsetX=0,this.dragOffsetY=0,this.isDragging=!1,this.isClick=!1,this.mouseDownPos={x:0,y:0},this.lastMouseX=0,this.lastMouseY=0,this.mouseX=this.width/2,this.mouseY=this.height/2,this.currentRippleColor=null,this.activeRipples=[],this.raycaster=new THREE.Raycaster,this.colorCycleStart=performance.now(),this.currentColorIndex=0,this.nextColorIndex=1%CONFIG.rippleColors.length,this.cyclingColor=new THREE.Color,this.isHovering=!1,this.wasHovering=!1,this.updateCyclingColor(),document.addEventListener("mousedown",t=>{this.isDragging=!0,this.isClick=!0,this.mouseDownPos={x:t.clientX,y:t.clientY},this.lastMouseX=t.clientX,this.lastMouseY=t.clientY}),document.addEventListener("mousemove",t=>{if(this.mouseX=t.clientX,this.mouseY=t.clientY,this.isDragging){Math.abs(t.clientX-this.mouseDownPos.x)+Math.abs(t.clientY-this.mouseDownPos.y)>5&&(this.isClick=!1);const e=t.clientX-this.lastMouseX,s=t.clientY-this.lastMouseY;this.dragOffsetY+=.004*e*CONFIG.dragInfluence,this.dragOffsetX+=.004*s*CONFIG.dragInfluence,this.dragOffsetX=Math.max(-.6,Math.min(.6,this.dragOffsetX)),this.dragOffsetY=Math.max(-.6,Math.min(.6,this.dragOffsetY)),this.lastMouseX=t.clientX,this.lastMouseY=t.clientY}this.isHovering=!0}),document.addEventListener("mouseleave",()=>{this.isHovering=!1}),document.addEventListener("mouseup",t=>{this.isClick&&this.handleClick(t.clientX,t.clientY),this.isDragging=!1,this.isClick=!1}),document.addEventListener("touchstart",t=>{1===t.touches.length&&(this.isDragging=!0,this.isClick=!0,this.mouseDownPos={x:t.touches[0].clientX,y:t.touches[0].clientY},this.lastMouseX=t.touches[0].clientX,this.lastMouseY=t.touches[0].clientY)},{passive:!0}),document.addEventListener("touchmove",t=>{if(!this.isDragging||1!==t.touches.length)return;Math.abs(t.touches[0].clientX-this.mouseDownPos.x)+Math.abs(t.touches[0].clientY-this.mouseDownPos.y)>10&&(this.isClick=!1);const e=t.touches[0].clientX-this.lastMouseX,s=t.touches[0].clientY-this.lastMouseY;this.dragOffsetY+=.004*e*CONFIG.dragInfluence,this.dragOffsetX+=.004*s*CONFIG.dragInfluence,this.dragOffsetX=Math.max(-.6,Math.min(.6,this.dragOffsetX)),this.dragOffsetY=Math.max(-.6,Math.min(.6,this.dragOffsetY)),this.lastMouseX=t.touches[0].clientX,this.lastMouseY=t.touches[0].clientY},{passive:!0}),document.addEventListener("touchend",t=>{this.isClick&&t.changedTouches.length>0&&this.handleClick(t.changedTouches[0].clientX,t.changedTouches[0].clientY),this.isDragging=!1,this.isClick=!1}),this.noise=new SimplexNoise,this.ribbons=[];for(let t=0;t<CONFIG.ribbonCount;t++){const t=new Ribbon3D(this.scene,this.noise,this);this.ribbons.push(t)}window.addEventListener("resize",()=>this.handleResize()),document.addEventListener("visibilitychange",()=>{document.hidden?this.pause():this.resume()});const e=document.getElementById("ribbon-js");e.addEventListener("webglcontextlost",t=>{t.preventDefault(),this.pause(),console.warn("WebGL context lost - pausing animation")}),e.addEventListener("webglcontextrestored",()=>{console.log("WebGL context restored - resuming"),this.resume()}),this.clock=new THREE.Clock,this.startTime=performance.now(),this.isPaused=!1,this.animate()}pause(){this.animationId&&(cancelAnimationFrame(this.animationId),this.animationId=null),this.clock.stop(),this.isPaused=!0}resume(){this.isPaused&&!this.animationId&&(this.clock.start(),this.isPaused=!1,this.animate())}handleResize(){this.width=window.innerWidth,this.height=window.innerHeight,this.camera.left=-this.width/2,this.camera.right=this.width/2,this.camera.top=this.height/2,this.camera.bottom=-this.height/2,this.camera.updateProjectionMatrix(),this.renderer.setSize(this.width,this.height);const t=this.isMobile?1.5:2;this.renderer.setPixelRatio(Math.min(window.devicePixelRatio,t)),this.composer.setSize(this.width,this.height),this.bloomPass&&this.bloomPass.resolution.set(this.width,this.height)}handleClick(t,e){const s=performance.now();for(const t of this.activeRipples){if(s-t.startTime<CONFIG.rippleTravelTime)return}if(this.lastClickTime&&s-this.lastClickTime<300)return;this.lastClickTime=s;const i=Math.random(),o=this.cyclingColor.clone();this.activeRipples.push({clickT:i,color:o,startTime:s}),window.dispatchEvent(new CustomEvent("ripplestart",{detail:{color:o}}))}updateRipples(){if(0===this.activeRipples.length)return;const t=performance.now(),e=CONFIG.rippleTravelTime+CONFIG.rippleFadeTime,s=[];for(let i=0;i<this.activeRipples.length;i++){const o=this.activeRipples[i],r=t-o.startTime;if(r>=e){s.push(i);continue}let n,h;if(r<CONFIG.rippleTravelTime)n=1-Math.pow(1-r/CONFIG.rippleTravelTime,2),h=0;else{n=1;h=(r-CONFIG.rippleTravelTime)/CONFIG.rippleFadeTime}for(const t of this.ribbons)for(const e of t.lines)e.applyRipple(o.clickT,o.color,n,h)}for(let t=s.length-1;t>=0;t--)this.activeRipples.splice(s[t],1);if(0===this.activeRipples.length){for(const t of this.ribbons)for(const e of t.lines)e.resetColors();this.lastRippleEnd=performance.now(),window.dispatchEvent(new CustomEvent("rippleend"))}}updateCyclingColor(){const t=performance.now(),e=t-this.colorCycleStart,s=Math.min(1,e/CONFIG.colorCycleTime),i=s<.5?2*s*s:1-Math.pow(-2*s+2,2)/2,o=CONFIG.rippleColors,r=o[this.currentColorIndex],n=o[this.nextColorIndex],h=(r[0]+(n[0]-r[0])*i)/255,a=(r[1]+(n[1]-r[1])*i)/255,l=(r[2]+(n[2]-r[2])*i)/255;this.cyclingColor.setRGB(h,a,l),s>=1&&(this.currentColorIndex=this.nextColorIndex,this.nextColorIndex=(this.nextColorIndex+1)%o.length,this.colorCycleStart=t)}applyHoverPreview(){const t=CONFIG.hoverPreviewIntensity;for(const e of this.ribbons)for(const s of e.lines){if(!s.lineMesh||!s.baseColor)continue;const e=s.lineMesh.geometry.attributes.color;if(!e)continue;const i=s.baseColor;for(let s=0;s<e.count;s++)e.array[3*s]=i.r+(this.cyclingColor.r-i.r)*t,e.array[3*s+1]=i.g+(this.cyclingColor.g-i.g)*t,e.array[3*s+2]=i.b+(this.cyclingColor.b-i.b)*t;e.needsUpdate=!0}}animate(){if(document.hidden||this.isPaused)return;const t=1e3*this.clock.getDelta(),e=Math.min(t,100);this.mouseInfluenceX+=(this.dragOffsetX-this.mouseInfluenceX)*CONFIG.influenceLerp,this.mouseInfluenceY+=(this.dragOffsetY-this.mouseInfluenceY)*CONFIG.influenceLerp;for(const t of this.ribbons)t.update(e);if(this.updateCyclingColor(),this.activeRipples.length>0)this.updateRipples();else if(this.isHovering)this.applyHoverPreview(),this.wasHovering=!0;else if(this.wasHovering){for(const t of this.ribbons)for(const e of t.lines)e.resetColors();this.wasHovering=!1}this.composer.render(),this.animationId=requestAnimationFrame(()=>this.animate())}}function initRibbon(){(window.requestIdleCallback||(t=>setTimeout(t,1)))(()=>{window.ribbonManager=new RibbonManager})}"loading"===document.readyState?document.addEventListener("DOMContentLoaded",initRibbon):initRibbon();