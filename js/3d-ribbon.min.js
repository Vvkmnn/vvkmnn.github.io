import*as c from"three";class J{constructor(o=Math.random()){this.p=new Uint8Array(256);for(let e=0;e<256;e++)this.p[e]=e;const s=this._createSeededRandom(o);for(let e=255;e>0;e--){const t=Math.floor(s()*(e+1));[this.p[e],this.p[t]]=[this.p[t],this.p[e]]}this.perm=new Uint8Array(512),this.permMod12=new Uint8Array(512);for(let e=0;e<512;e++)this.perm[e]=this.p[e&255],this.permMod12[e]=this.perm[e]%12}_createSeededRandom(o){return function(){const s=Math.sin(o++)*1e4;return s-Math.floor(s)}}noise3D(o,s,e){const t=[[1,1,0],[-1,1,0],[1,-1,0],[-1,-1,0],[1,0,1],[-1,0,1],[1,0,-1],[-1,0,-1],[0,1,1],[0,-1,1],[0,1,-1],[0,-1,-1]],n=1/3,i=1/6,r=(o+s+e)*n,h=Math.floor(o+r),l=Math.floor(s+r),u=Math.floor(e+r),p=(h+l+u)*i,M=h-p,d=l-p,f=u-p,C=o-M,b=s-d,v=e-f;let g,m,P,y,x,R;C>=b?b>=v?(g=1,m=0,P=0,y=1,x=1,R=0):C>=v?(g=1,m=0,P=0,y=1,x=0,R=1):(g=0,m=0,P=1,y=1,x=0,R=1):b<v?(g=0,m=0,P=1,y=0,x=1,R=1):C<v?(g=0,m=1,P=0,y=0,x=1,R=1):(g=0,m=1,P=0,y=1,x=1,R=0);const F=C-g+i,A=b-m+i,z=v-P+i,E=C-y+2*i,S=b-x+2*i,V=v-R+2*i,B=C-1+3*i,j=b-1+3*i,G=v-1+3*i,O=h&255,L=l&255,Y=u&255,H=this.permMod12[O+this.perm[L+this.perm[Y]]],W=this.permMod12[O+g+this.perm[L+m+this.perm[Y+P]]],U=this.permMod12[O+y+this.perm[L+x+this.perm[Y+R]]],N=this.permMod12[O+1+this.perm[L+1+this.perm[Y+1]]];let T=.6-C*C-b*b-v*v,Z=0;T>=0&&(T*=T,Z=T*T*(t[H][0]*C+t[H][1]*b+t[H][2]*v));let k=.6-F*F-A*A-z*z,_=0;k>=0&&(k*=k,_=k*k*(t[W][0]*F+t[W][1]*A+t[W][2]*z));let D=.6-E*E-S*S-V*V,K=0;D>=0&&(D*=D,K=D*D*(t[U][0]*E+t[U][1]*S+t[U][2]*V));let X=.6-B*B-j*j-G*G,Q=0;return X>=0&&(X*=X,Q=X*X*(t[N][0]*B+t[N][1]*j+t[N][2]*G)),32*(Z+_+K+Q)}}const a={lineCount:42,ribbonWidthRatio:.5,pointsPerLine:350,drawDuration:2500,morphDuration:3e3,staggerDelay:45,holdDuration:6e3,curveScaleMultiplier:.69,depthMultiplier:.15,numControlPoints:100,ribbonCount:1,rotationSpeed:75e-5,baseTiltX:.25,baseTiltZ:.12,numCurveVariations:13,lineColor:1118481,backgroundColor:16316404,lightLineColor:9474192,lightBackgroundColor:16118767,lightFillColor:16118767,darkLineColor:13684944,darkBackgroundColor:1184274,darkFillColor:1973790,rippleColors:[[230,25,75],[173,48,41],[219,187,48],[255,128,0],[85,88,218],[255,180,160],[100,200,130],[229,114,94],[42,201,185],[200,100,180],[0,128,128]],rippleTravelTime:2500,rippleFadeTime:3e3,rippleWidth:.25,rippleIntensity:1.4,dragInfluence:.5,influenceLerp:.04,mouseLightRadius:80,mouseLightIntensity:.4,colorCycleTime:2500,hoverPreviewIntensity:.35};a.fillColor=a.lightFillColor;const $=document.documentElement.classList.contains("dark");$&&(a.lineColor=a.darkLineColor,a.backgroundColor=a.darkBackgroundColor,a.fillColor=a.darkFillColor),window.addEventListener("themechange",w=>{const o=w.detail?.isDark,s=o?a.darkLineColor:a.lightLineColor,e=o?a.darkBackgroundColor:a.lightBackgroundColor,t=o?a.darkFillColor:a.lightFillColor;if(window.ribbonManager){let d=function(f){const C=f-i,b=Math.min(C/500,1),v=b<.5?2*b*b:1-Math.pow(-2*b+2,2)/2;window.ribbonManager.scene.background.lerpColors(r,h,v);const g=new c.Color().lerpColors(l,u,v),m=new c.Color().lerpColors(p,M,v);for(const P of window.ribbonManager.ribbons){for(const y of P.lines)y.updateBaseColor(g.getHex());for(const y of P.fillMeshes)y.mesh.material.color.copy(m)}b<1?requestAnimationFrame(d):(a.lineColor=s,a.backgroundColor=e,a.fillColor=t)};const i=performance.now(),r=window.ribbonManager.scene.background.clone(),h=new c.Color(e),l=new c.Color(a.lineColor),u=new c.Color(s),p=new c.Color(a.fillColor),M=new c.Color(t);requestAnimationFrame(d)}else a.lineColor=s,a.backgroundColor=e,a.fillColor=t});const tt=[{x:.15,y:.3,z:.1},{x:.25,y:.4,z:.1},{x:.3,y:.2,z:.05},{x:.2,y:.5,z:.12},{x:.22,y:.35,z:.08},{x:.28,y:.25,z:.1},{x:.2,y:.45,z:.12},{x:.22,y:.38,z:.08},{x:.2,y:.35,z:.1},{x:.25,y:.35,z:.1},{x:.24,y:.4,z:.1},{x:.22,y:.38,z:.08},{x:.26,y:.32,z:.1}];function et(w,o){const s={tangents:[],normals:[],binormals:[]};for(let d=0;d<=o;d++)s.tangents.push(w.getTangent(d/o).normalize());const e=s.tangents[0];let t=Math.abs(e.x)<.9?new c.Vector3(1,0,0):new c.Vector3(0,1,0);t.crossVectors(t,e).normalize();const n=[t.clone()];for(let d=1;d<=o;d++){const f=s.tangents[d-1],C=s.tangents[d],b=new c.Vector3().crossVectors(f,C);if(b.length()>1e-4){b.normalize();const v=Math.acos(Math.min(1,Math.max(-1,f.dot(C))));t=n[d-1].clone().applyAxisAngle(b,v)}else t=n[d-1].clone();n.push(t)}const i=n[0],r=n[o],h=s.tangents[o],l=i.clone().projectOnPlane(h).normalize(),u=r.clone().projectOnPlane(h).normalize();let p=Math.acos(Math.min(1,Math.max(-1,l.dot(u))));new c.Vector3().crossVectors(u,l).dot(h)<0&&(p=-p);for(let d=0;d<=o;d++){const f=p*d/o,C=n[d].clone().applyAxisAngle(s.tangents[d],f);s.normals.push(C),s.binormals.push(new c.Vector3().crossVectors(s.tangents[d],C))}return s}function st(w,o,s,e,t,n,i,r){const h=[];for(let l=0;l<r;l++){const u=l/r*Math.PI*2;h.push(new c.Vector3(Math.cos(w*u+e)*i.x,Math.cos(o*u+t)*i.y,Math.cos(s*u+n)*i.z))}return new c.CatmullRomCurve3(h,!0,"centripetal",.5)}function I(w,o,s,e,t,n){const i=[];for(let r=0;r<n;r++){const h=r/n*Math.PI*2;i.push(new c.Vector3(Math.cos(w*h)*(s+e*Math.cos(o*h))*t,Math.sin(w*h)*(s+e*Math.cos(o*h))*t,e*Math.sin(o*h)*t))}return new c.CatmullRomCurve3(i,!0,"centripetal",.5)}function it(w,o){const s=[];for(let e=0;e<o;e++){const t=e/o*Math.PI*2;s.push(new c.Vector3((Math.sin(t)+2*Math.sin(2*t))*w*.35,(Math.cos(t)-2*Math.cos(2*t))*w*.35,-Math.sin(3*t)*w*.25))}return new c.CatmullRomCurve3(s,!0,"centripetal",.5)}function rt(w,o){const s=[];for(let e=0;e<o;e++){const t=e/o*Math.PI*2;s.push(new c.Vector3((2+Math.cos(2*t))*Math.cos(3*t)*w*.22,(2+Math.cos(2*t))*Math.sin(3*t)*w*.22,Math.sin(4*t)*w*.18))}return new c.CatmullRomCurve3(s,!0,"centripetal",.5)}function at(w,o){const s=[];for(let e=0;e<o;e++){const t=e/o*Math.PI*2;s.push(new c.Vector3(Math.cos(2*t)*(3+Math.cos(5*t))*w*.12,Math.sin(2*t)*(3+Math.cos(5*t))*w*.12,Math.sin(5*t)*w*.15))}return new c.CatmullRomCurve3(s,!0,"centripetal",.5)}class ot{constructor(o,s,e,t,n){this.scene=e,this.noise=t,this.index=o;const i=(s-1)/2;this.baseOffset=(o-i)*n,this.drawProgress=0,this.morphProgress=0,this.oldPositions=null,this.newPositions=null,this.isMorphing=!1,this.mesh=null}startMorph(o,s){if(!this.mesh)return;const e=this.mesh.geometry.attributes.position;this.oldPositions=new Float32Array(e.array),this.newPositions=new Float32Array(this.generatePositions(o,s)),this.isMorphing=!0,this.morphProgress=0}interpolateMorph(o){if(!this.isMorphing||!this.oldPositions||!this.newPositions||!this.mesh)return;const s=this.mesh.geometry.attributes.position,e=s.count,t=.15,n=-t+o*(1+t*2);for(let i=0;i<e;i++){const r=i/(e-1);let h;if(r<=n-t)h=1;else if(r>=n+t)h=0;else{const u=(n+t-r)/(t*2);h=u*u*(3-2*u)}const l=i*3;s.array[l]=this.oldPositions[l]+(this.newPositions[l]-this.oldPositions[l])*h,s.array[l+1]=this.oldPositions[l+1]+(this.newPositions[l+1]-this.oldPositions[l+1])*h,s.array[l+2]=this.oldPositions[l+2]+(this.newPositions[l+2]-this.oldPositions[l+2])*h}s.needsUpdate=!0}finishMorph(){this.isMorphing=!1,this.oldPositions=null,this.newPositions=null}updateBaseColor(o){if(this.baseColor=new c.Color(o),this.mesh){const s=this.mesh.geometry.attributes.color;if(s){for(let e=0;e<s.count;e++)s.array[e*3]=this.baseColor.r,s.array[e*3+1]=this.baseColor.g,s.array[e*3+2]=this.baseColor.b;s.needsUpdate=!0}}}generatePositions(o,s){const e=[],t=et(o,a.pointsPerLine);for(let n=0;n<=a.pointsPerLine;n++){const i=n/a.pointsPerLine,r=o.getPoint(i),h=t.binormals[n],l=this.baseOffset;e.push(r.x+h.x*l,r.y+h.y*l,r.z+h.z*l)}return e}createMesh(o,s){this.mesh&&(this.mesh.geometry.dispose(),this.scene.remove(this.mesh));const e=this.generatePositions(o,s),t=new c.BufferGeometry;t.setAttribute("position",new c.Float32BufferAttribute(e,3));const n=e.length/3,i=new Float32Array(n*3),r=new c.Color(a.lineColor);for(let l=0;l<n;l++)i[l*3]=r.r,i[l*3+1]=r.g,i[l*3+2]=r.b;t.setAttribute("color",new c.Float32BufferAttribute(i,3));const h=new c.LineBasicMaterial({vertexColors:!0,depthWrite:!0,depthTest:!0});this.mesh=new c.Line(t,h),this.mesh.renderOrder=1,this.scene.add(this.mesh),this.baseColor=r.clone(),t.setDrawRange(0,0)}updatePositions(o,s){if(!this.mesh)return;const e=this.generatePositions(o,s),t=this.mesh.geometry.attributes.position;for(let n=0;n<e.length;n++)t.array[n]=e[n];t.needsUpdate=!0}applyRipple(o,s,e,t){if(!this.mesh||!this.baseColor)return;const n=this.mesh.geometry.attributes.color;if(!n)return;const i=n.count,r=a.rippleWidth;for(let h=0;h<i;h++){const l=h/(i-1);let u=Math.abs(l-o);u>.5&&(u=1-u);const p=e*.5;let M=0;if(e<1){if(u<=p){const d=p-u;d<r&&(M=Math.sin((1-d/r)*Math.PI*.5))}if(u<r*.3){const d=1-u/(r*.3);M=Math.max(M,d)}}else if(u<=.5){const d=1-u*.5,f=1-Math.pow(t,.4);M=d*f}M=Math.min(1,M*a.rippleIntensity),n.array[h*3]=this.baseColor.r+(s.r-this.baseColor.r)*M,n.array[h*3+1]=this.baseColor.g+(s.g-this.baseColor.g)*M,n.array[h*3+2]=this.baseColor.b+(s.b-this.baseColor.b)*M}n.needsUpdate=!0}resetColors(){if(!this.mesh||!this.baseColor)return;const o=this.mesh.geometry.attributes.color;if(o){for(let s=0;s<o.count;s++)o.array[s*3]=this.baseColor.r,o.array[s*3+1]=this.baseColor.g,o.array[s*3+2]=this.baseColor.b;o.needsUpdate=!0}}dispose(){this.mesh&&(this.mesh.geometry.dispose(),this.mesh.material.dispose(),this.scene.remove(this.mesh))}}class nt{constructor(o,s,e=null){this.scene=o,this.noise=s,this.manager=e,this.time=0,this.lines=[],this.fillMeshes=[],this.curves=[],this.currentCurveIndex=0,this.nextCurveIndex=1,this.generateCurveVariations(),this.phase="drawing",this.phaseStartTime=0,this.holdTimer=0,this.rotationTime=0,this.ribbonGroup=new c.Group,this.scene.add(this.ribbonGroup);const t=this.curveOrder[0];this.currentCurveIndex=t;const n=tt[t]||{x:.2,y:.3,z:.1};this.ribbonGroup.rotation.set(n.x,n.y,n.z),this.rotationTime=n.y/.06;for(let i=0;i<a.lineCount;i++){const r=new ot(i,a.lineCount,this.ribbonGroup,this.noise,this.lineSpacing);r.createMesh(this.curves[t],this.time),this.lines.push(r)}this.createFillMeshes()}generateCurveVariations(){const o=window.innerWidth,s=window.innerHeight,e=Math.min(o,s)*a.curveScaleMultiplier,t=e*a.depthMultiplier,n=a.numControlPoints,l=Math.min(o,s)<600?.7:.5,u=e*l;this.lineSpacing=u/(a.lineCount-1);const p=[];for(let g=0;g<n;g++){const m=g/n*Math.PI*2;p.push(new c.Vector3(Math.sin(m)*e*.9,Math.sin(m*2)*e*.55,Math.sin(m+Math.PI/4)*t*1.5))}this.curves.push(new c.CatmullRomCurve3(p,!0,"centripetal",.5)),this.curves.push(it(e*1.3,n)),this.curves.push(I(2,3,e*.6,e*.35,1,n)),this.curves.push(st(2,3,5,0,Math.PI/4,0,{x:e,y:e*.75,z:t},n)),this.curves.push(I(2,5,e*.5,e*.28,1,n)),this.curves.push(I(3,2,e*.55,e*.32,1,n)),this.curves.push(I(3,4,e*.48,e*.26,1,n)),this.curves.push(I(2,7,e*.5,e*.28,1,n));const M=[],d=e*.65;for(let g=0;g<n;g++){const m=g/n*Math.PI*2;M.push(new c.Vector3(d*Math.pow(Math.cos(m),3),d*Math.pow(Math.sin(m),3),t*.6*Math.sin(2*m)))}this.curves.push(new c.CatmullRomCurve3(M,!0,"centripetal",.5));const f=[],C=e*.35;for(let g=0;g<n;g++){const m=g/n*Math.PI*2;f.push(new c.Vector3(C*(3*Math.cos(m)-Math.cos(3*m)),C*(3*Math.sin(m)-Math.sin(3*m)),t*.8*Math.sin(2*m)))}this.curves.push(new c.CatmullRomCurve3(f,!0,"centripetal",.5)),this.curves.push(I(3,7,e*.48,e*.25,1,n));const b=[],v=e*.55;for(let g=0;g<n;g++){const m=g/n*Math.PI*2;b.push(new c.Vector3(v*(2*Math.cos(m)+Math.cos(2*m)),v*(2*Math.sin(m)-Math.sin(2*m)),t*.7*Math.sin(1.5*m)))}this.curves.push(new c.CatmullRomCurve3(b,!0,"centripetal",.5)),this.curves.push(I(4,3,e*.5,e*.28,1,n)),this.curveOrder=this.shuffleArray([...Array(this.curves.length).keys()]),this.curveOrderIndex=0}shuffleArray(o){const s=[...o];for(let e=s.length-1;e>0;e--){const t=Math.floor(Math.random()*(e+1));[s[e],s[t]]=[s[t],s[e]]}return s}createFillMeshes(){for(let o=0;o<this.lines.length-1;o++){const s=this.lines[o],e=this.lines[o+1],t=new c.BufferGeometry,n=[],i=[],r=s.mesh.geometry.attributes.position.array,h=e.mesh.geometry.attributes.position.array,l=a.pointsPerLine+1;for(let d=0;d<l;d++){const f=d*3;n.push(r[f],r[f+1],r[f+2]),n.push(h[f],h[f+1],h[f+2])}const u=(l-1)*2;for(let d=0;d<l-1;d++){const f=d*2;i.push(f,f+1,f+2),i.push(f+1,f+3,f+2)}t.setAttribute("position",new c.Float32BufferAttribute(n,3)),t.setIndex(i);const p=new c.MeshBasicMaterial({color:new c.Color(a.fillColor),side:c.DoubleSide,depthWrite:!0,depthTest:!0,polygonOffset:!0,polygonOffsetFactor:2,polygonOffsetUnits:2}),M=new c.Mesh(t,p);M.renderOrder=-1,this.ribbonGroup.add(M),this.fillMeshes.push({mesh:M,line1Index:o,line2Index:o+1,totalTriangles:u}),t.setDrawRange(0,0)}}updateFillMeshPositions(o){const s=this.fillMeshes[o],e=this.lines[s.line1Index],t=this.lines[s.line2Index],n=e.mesh.geometry.attributes.position.array,i=t.mesh.geometry.attributes.position.array,r=s.mesh.geometry.attributes.position.array,h=a.pointsPerLine+1;for(let l=0;l<h;l++){const u=l*3,p=l*6;r[p]=n[u],r[p+1]=n[u+1],r[p+2]=n[u+2],r[p+3]=i[u],r[p+4]=i[u+1],r[p+5]=i[u+2]}s.mesh.geometry.attributes.position.needsUpdate=!0}updateFillMeshes(){const s=a.pointsPerLine+1-1;for(let e=0;e<this.fillMeshes.length;e++){const t=this.fillMeshes[e],n=this.lines[t.line1Index],i=this.lines[t.line2Index];let r,h;this.phase==="drawing"?(r=n.drawProgress,h=i.drawProgress):this.phase==="morphing"?(n.morphProgress<=.5?r=1-n.morphProgress*2:r=(n.morphProgress-.5)*2,i.morphProgress<=.5?h=1-i.morphProgress*2:h=(i.morphProgress-.5)*2):(r=1,h=1);const l=Math.min(r,h),p=Math.floor(l*s)*6;t.mesh.geometry.setDrawRange(0,p)}}updateRotation(o){this.spinRateX===void 0&&(this.spinRateX=14e-6,this.spinRateY=56e-6,this.currentRotationX=a.baseTiltX,this.currentRotationY=0,this.currentRotationZ=a.baseTiltZ,this.lastDragX=0,this.lastDragY=0);const s=this.manager?.dragOffsetX||0,e=this.manager?.dragOffsetY||0,t=s-this.lastDragX,n=e-this.lastDragY;this.lastDragX=s,this.lastDragY=e,this.spinRateY+=n*56e-5,this.spinRateX+=t*42e-5,this.spinRateY=Math.max(-28e-5,Math.min(28e-5,this.spinRateY)),this.spinRateX=Math.max(-21e-5,Math.min(21e-5,this.spinRateX)),this.currentRotationX+=this.spinRateX*o,this.currentRotationY+=this.spinRateY*o,this.rotationTime=(this.rotationTime||0)+o*a.rotationSpeed;const i=a.baseTiltZ+Math.sin(this.rotationTime*.5)*.06;this.ribbonGroup.rotation.set(this.currentRotationX,this.currentRotationY,i)}update(o){this.time+=o*.001,this.updateRotation(o);const s=a.pointsPerLine+1,e=this.time*1e3-this.phaseStartTime;switch(this.phase){case"drawing":for(let i=0;i<this.lines.length;i++){const r=i*a.staggerDelay;if(e>=r){const h=e-r;this.lines[i].drawProgress=Math.min(1,h/a.drawDuration);const l=Math.floor(this.lines[i].drawProgress*s);this.lines[i].mesh.geometry.setDrawRange(0,l)}}this.lines[this.lines.length-1].drawProgress>=1&&(this.phase="holding",this.phaseStartTime=this.time*1e3,this.holdTimer=0);break;case"holding":if(this.holdTimer+=o,this.holdTimer>=a.holdDuration){if(this.phase="morphing",this.phaseStartTime=this.time*1e3,this.curveSwapped=!1,this.nextCurveIndex=this.curveOrder[this.curveOrderIndex],this.curveOrderIndex=(this.curveOrderIndex+1)%this.curveOrder.length,this.curveOrderIndex===0){const i=this.currentCurveIndex;if(this.curveOrder=this.shuffleArray(this.curveOrder),this.curveOrder[0]===i&&this.curveOrder.length>1){const r=1+Math.floor(Math.random()*(this.curveOrder.length-1));[this.curveOrder[0],this.curveOrder[r]]=[this.curveOrder[r],this.curveOrder[0]]}}for(const i of this.lines)i.morphProgress=0}break;case"morphing":for(let i=0;i<this.lines.length;i++){const r=this.lines[i],h=i*a.staggerDelay;if(e>=h){const l=e-h,u=r.morphProgress;if(r.morphProgress=Math.min(1,l/a.morphDuration),u<.5&&r.morphProgress>=.5&&(r.updatePositions(this.curves[this.nextCurveIndex],this.time),i>0&&this.fillMeshes[i-1]&&this.updateFillMeshPositions(i-1),i<this.lines.length-1&&this.fillMeshes[i]&&this.updateFillMeshPositions(i)),r.morphProgress<=.5){const p=r.morphProgress*2,M=Math.floor((1-p)*s);r.mesh.geometry.setDrawRange(0,Math.max(1,M))}else{const p=(r.morphProgress-.5)*2,M=Math.floor(p*s);r.mesh.geometry.setDrawRange(0,M)}}}if(this.updateFillMeshes(),this.lines[this.lines.length-1].morphProgress>=1){this.phase="holding",this.phaseStartTime=this.time*1e3,this.holdTimer=0,this.currentCurveIndex=this.nextCurveIndex;for(const i of this.lines)i.finishMorph(),i.drawProgress=1,i.mesh.geometry.setDrawRange(0,s)}break}this.updateFillMeshes()}dispose(){for(const o of this.lines)o.dispose();for(const o of this.fillMeshes)o.mesh.geometry.dispose(),o.mesh.material.dispose(),this.ribbonGroup.remove(o.mesh);this.fillMeshes=[],this.scene.remove(this.ribbonGroup)}}class q{constructor(){this.width=window.innerWidth,this.height=window.innerHeight,this.scene=new c.Scene,this.scene.background=new c.Color(a.backgroundColor);const o=Math.min(this.width,this.height);this.camera=new c.OrthographicCamera(-this.width/2,this.width/2,this.height/2,-this.height/2,.1,3e3),this.camera.position.z=1e3,this.isMobile=/Android|iPhone|iPad|iPod/i.test(navigator.userAgent),this.renderer=new c.WebGLRenderer({canvas:document.getElementById("ribbon-js"),antialias:!0,alpha:!1,powerPreference:"high-performance",stencil:!1,depth:!0,premultipliedAlpha:!1,preserveDrawingBuffer:!1,failIfMajorPerformanceCaveat:!1}),this.renderer.setSize(this.width,this.height);const s=this.isMobile?1.5:2;this.renderer.setPixelRatio(Math.min(window.devicePixelRatio,s)),this.mouseInfluenceX=0,this.mouseInfluenceY=0,this.dragOffsetX=0,this.dragOffsetY=0,this.isDragging=!1,this.isClick=!1,this.mouseDownPos={x:0,y:0},this.lastMouseX=0,this.lastMouseY=0,this.mouseX=this.width/2,this.mouseY=this.height/2,this.currentRippleColor=null,this.activeRipples=[],this.raycaster=new c.Raycaster,this.colorCycleStart=performance.now(),this.currentColorIndex=0,this.nextColorIndex=1%a.rippleColors.length,this.cyclingColor=new c.Color,this.isHovering=!1,this.wasHovering=!1,this.updateCyclingColor(),document.addEventListener("mousedown",t=>{this.isDragging=!0,this.isClick=!0,this.mouseDownPos={x:t.clientX,y:t.clientY},this.lastMouseX=t.clientX,this.lastMouseY=t.clientY}),document.addEventListener("mousemove",t=>{if(this.mouseX=t.clientX,this.mouseY=t.clientY,this.isDragging){Math.abs(t.clientX-this.mouseDownPos.x)+Math.abs(t.clientY-this.mouseDownPos.y)>5&&(this.isClick=!1);const i=t.clientX-this.lastMouseX,r=t.clientY-this.lastMouseY;this.dragOffsetY+=i*.004*a.dragInfluence,this.dragOffsetX+=r*.004*a.dragInfluence,this.dragOffsetX=Math.max(-.6,Math.min(.6,this.dragOffsetX)),this.dragOffsetY=Math.max(-.6,Math.min(.6,this.dragOffsetY)),this.lastMouseX=t.clientX,this.lastMouseY=t.clientY}this.isHovering=!0}),document.addEventListener("mouseleave",()=>{this.isHovering=!1}),document.addEventListener("mouseup",t=>{this.isClick&&this.handleClick(t.clientX,t.clientY),this.isDragging=!1,this.isClick=!1}),document.addEventListener("touchstart",t=>{t.touches.length===1&&(this.isDragging=!0,this.isClick=!0,this.mouseDownPos={x:t.touches[0].clientX,y:t.touches[0].clientY},this.lastMouseX=t.touches[0].clientX,this.lastMouseY=t.touches[0].clientY)},{passive:!0}),document.addEventListener("touchmove",t=>{if(!this.isDragging||t.touches.length!==1)return;Math.abs(t.touches[0].clientX-this.mouseDownPos.x)+Math.abs(t.touches[0].clientY-this.mouseDownPos.y)>10&&(this.isClick=!1);const i=t.touches[0].clientX-this.lastMouseX,r=t.touches[0].clientY-this.lastMouseY;this.dragOffsetY+=i*.004*a.dragInfluence,this.dragOffsetX+=r*.004*a.dragInfluence,this.dragOffsetX=Math.max(-.6,Math.min(.6,this.dragOffsetX)),this.dragOffsetY=Math.max(-.6,Math.min(.6,this.dragOffsetY)),this.lastMouseX=t.touches[0].clientX,this.lastMouseY=t.touches[0].clientY},{passive:!0}),document.addEventListener("touchend",t=>{this.isClick&&t.changedTouches.length>0&&this.handleClick(t.changedTouches[0].clientX,t.changedTouches[0].clientY),this.isDragging=!1,this.isClick=!1}),this.noise=new J,this.ribbons=[];for(let t=0;t<a.ribbonCount;t++){const n=new nt(this.scene,this.noise,this);this.ribbons.push(n)}window.addEventListener("resize",()=>this.handleResize()),document.addEventListener("visibilitychange",()=>{document.hidden?this.pause():this.resume()});const e=document.getElementById("ribbon-js");e.addEventListener("webglcontextlost",t=>{t.preventDefault(),this.pause(),console.warn("WebGL context lost - pausing animation")}),e.addEventListener("webglcontextrestored",()=>{console.log("WebGL context restored - resuming"),this.resume()}),this.clock=new c.Clock,this.startTime=performance.now(),this.isPaused=!1,this.animate()}pause(){this.animationId&&(cancelAnimationFrame(this.animationId),this.animationId=null),this.clock.stop(),this.isPaused=!0}resume(){this.isPaused&&!this.animationId&&(this.clock.start(),this.isPaused=!1,this.animate())}handleResize(){this.width=window.innerWidth,this.height=window.innerHeight,this.camera.left=-this.width/2,this.camera.right=this.width/2,this.camera.top=this.height/2,this.camera.bottom=-this.height/2,this.camera.updateProjectionMatrix(),this.renderer.setSize(this.width,this.height);const o=this.isMobile?1.5:2;this.renderer.setPixelRatio(Math.min(window.devicePixelRatio,o))}handleClick(o,s){const e=performance.now();for(const i of this.activeRipples)if(e-i.startTime<a.rippleTravelTime)return;if(this.lastClickTime&&e-this.lastClickTime<300)return;this.lastClickTime=e;const t=Math.random(),n=this.cyclingColor.clone();this.activeRipples.push({clickT:t,color:n,startTime:e}),window.dispatchEvent(new CustomEvent("ripplestart",{detail:{color:n}}))}updateRipples(){if(this.activeRipples.length===0)return;const o=performance.now(),s=a.rippleTravelTime+a.rippleFadeTime,e=[];for(let t=0;t<this.activeRipples.length;t++){const n=this.activeRipples[t],i=o-n.startTime;if(i>=s){e.push(t);continue}let r,h;i<a.rippleTravelTime?(r=1-Math.pow(1-i/a.rippleTravelTime,2),h=0):(r=1,h=(i-a.rippleTravelTime)/a.rippleFadeTime);for(const l of this.ribbons)for(const u of l.lines)u.applyRipple(n.clickT,n.color,r,h)}for(let t=e.length-1;t>=0;t--)this.activeRipples.splice(e[t],1);if(this.activeRipples.length===0){for(const t of this.ribbons)for(const n of t.lines)n.resetColors();this.lastRippleEnd=performance.now(),window.dispatchEvent(new CustomEvent("rippleend"))}}updateCyclingColor(){const o=performance.now(),s=o-this.colorCycleStart,e=Math.min(1,s/a.colorCycleTime),t=e<.5?2*e*e:1-Math.pow(-2*e+2,2)/2,n=a.rippleColors,i=n[this.currentColorIndex],r=n[this.nextColorIndex],h=(i[0]+(r[0]-i[0])*t)/255,l=(i[1]+(r[1]-i[1])*t)/255,u=(i[2]+(r[2]-i[2])*t)/255;this.cyclingColor.setRGB(h,l,u),e>=1&&(this.currentColorIndex=this.nextColorIndex,this.nextColorIndex=(this.nextColorIndex+1)%n.length,this.colorCycleStart=o)}applyHoverPreview(){const o=a.hoverPreviewIntensity;for(const s of this.ribbons)for(const e of s.lines){if(!e.lineMesh||!e.baseColor)continue;const t=e.lineMesh.geometry.attributes.color;if(!t)continue;const n=e.baseColor;for(let i=0;i<t.count;i++)t.array[i*3]=n.r+(this.cyclingColor.r-n.r)*o,t.array[i*3+1]=n.g+(this.cyclingColor.g-n.g)*o,t.array[i*3+2]=n.b+(this.cyclingColor.b-n.b)*o;t.needsUpdate=!0}}animate(){if(document.hidden||this.isPaused)return;const o=this.clock.getDelta()*1e3,s=Math.min(o,100);this.mouseInfluenceX+=(this.dragOffsetX-this.mouseInfluenceX)*a.influenceLerp,this.mouseInfluenceY+=(this.dragOffsetY-this.mouseInfluenceY)*a.influenceLerp;for(const e of this.ribbons)e.update(s);if(this.updateCyclingColor(),this.activeRipples.length>0)this.updateRipples();else if(this.isHovering)this.applyHoverPreview(),this.wasHovering=!0;else if(this.wasHovering){for(const e of this.ribbons)for(const t of e.lines)t.resetColors();this.wasHovering=!1}this.renderer.render(this.scene,this.camera),this.animationId=requestAnimationFrame(()=>this.animate())}}document.readyState==="loading"?document.addEventListener("DOMContentLoaded",()=>{window.ribbonManager=new q}):window.ribbonManager=new q;
